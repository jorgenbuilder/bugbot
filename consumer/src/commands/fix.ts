import { QueueMessage, LinearIssue } from '@bugbot/shared';
import { createLinearClient, getIssue, addComment } from '../clients/linear';
import { createGitHubClient, searchCode, createBranch, createPullRequest } from '../clients/github';
import { sendDiscordMessage } from '../index';
import { REPO_URL } from '../config';

interface Env {
  BUGBOT_KV: KVNamespace;
  LINEAR_API_KEY: string;
  GITHUB_TOKEN: string;
  DISCORD_BOT_TOKEN: string;
  CLOUDFLARE_ACCOUNT_ID: string;
  CLOUDFLARE_API_TOKEN: string;
  CONTAINER_BINDING_NAME?: string;
}

export async function handleFix(msg: QueueMessage, env: Env): Promise<void> {
  const linearClient = createLinearClient(env.LINEAR_API_KEY);
  const githubClient = createGitHubClient(env.GITHUB_TOKEN);

  // 1. Load Linear issue
  let linearIssue: LinearIssue | null = null;

  if (msg.extractedRefs.linearIssueId) {
    linearIssue = await getIssue(linearClient, msg.extractedRefs.linearIssueId);
  }

  if (!linearIssue) {
    // Check KV mapping
    const kvKey = `discord:${msg.discordContext.threadId || msg.discordContext.channelId}`;
    const mappedIssueId = await env.BUGBOT_KV.get(kvKey);

    if (mappedIssueId) {
      linearIssue = await getIssue(linearClient, mappedIssueId);
    }
  }

  if (!linearIssue) {
    throw new Error('No Linear issue found. Run `@bugbot contextualize` first.');
  }

  // 2. Use hardcoded repo
  const githubRepoUrl = REPO_URL;

  // 3. Search for relevant frontend files
  const searchQuery = extractSearchTerms(linearIssue.title, linearIssue.description);
  const codeFiles = await searchCode(githubClient, githubRepoUrl, searchQuery);

  if (codeFiles.length === 0) {
    throw new Error(`No relevant files found for query: "${searchQuery}"`);
  }

  // Filter to frontend paths only (allowlist)
  const frontendFiles = codeFiles.filter(file =>
    file.path.startsWith('src/') ||
    file.path.startsWith('app/') ||
    file.path.startsWith('components/') ||
    file.path.startsWith('pages/')
  );

  if (frontendFiles.length === 0) {
    throw new Error('No frontend files found in search results');
  }

  // 4. Execute Claude Code in container
  const branchName = `bugbot-fix-${linearIssue.identifier.toLowerCase()}-${Date.now()}`;
  const executionResult = await executeClaudeCodeFix(
    env,
    githubRepoUrl,
    branchName,
    linearIssue,
    frontendFiles.slice(0, 5) // Limit to top 5 files
  );

  if (!executionResult.success) {
    throw new Error(executionResult.error || 'Claude Code execution failed');
  }

  // 5. Create PR
  const prTitle = `Fix: ${linearIssue.title}`;
  const prBody = `
Fixes ${linearIssue.url}

## Changes
${executionResult.changes || 'Automated fix by @bugbot'}

## Testing
- [ ] Verify fix resolves issue
- [ ] Check Vercel preview deployment

Generated by @bugbot ðŸ¤–
  `.trim();

  const prUrl = await createPullRequest(
    githubClient,
    githubRepoUrl,
    prTitle,
    prBody,
    branchName
  );

  // 6. Update Linear and Discord
  await addComment(
    linearClient,
    linearIssue.id,
    `## Fix PR Created\n\n[View PR](${prUrl})\n\nBranch: \`${branchName}\`\n\nGenerated by @bugbot ðŸ¤–`
  );

  await sendDiscordMessage(
    msg.discordContext.channelId,
    `âœ… Created PR for [${linearIssue.identifier}](${linearIssue.url}): ${prUrl}`,
    env.DISCORD_BOT_TOKEN
  );
}

function extractSearchTerms(title: string, description?: string): string {
  // Extract key terms from title and description
  const text = [title, description].filter(Boolean).join(' ');

  // Remove common words and extract meaningful terms
  const terms = text
    .toLowerCase()
    .replace(/[^\w\s]/g, ' ')
    .split(/\s+/)
    .filter(word => word.length > 3)
    .filter(word => !['button', 'issue', 'error', 'when', 'should', 'would', 'could'].includes(word))
    .slice(0, 3);

  return terms.join(' ') || 'frontend component';
}

async function executeClaudeCodeFix(
  env: Env,
  repoUrl: string,
  branchName: string,
  linearIssue: LinearIssue,
  relevantFiles: Array<{ path: string; url: string }>
): Promise<{ success: boolean; changes?: string; error?: string }> {
  // Build the prompt for Claude Code
  const prompt = `
Fix the following issue in the codebase:

Issue: ${linearIssue.title}
${linearIssue.description ? `\nDescription:\n${linearIssue.description}` : ''}

Relevant files to check:
${relevantFiles.map(f => `- ${f.path}`).join('\n')}

Instructions:
1. Clone the repository: ${repoUrl}
2. Create and checkout branch: ${branchName}
3. Identify the bug in the relevant files
4. Apply a minimal fix (frontend files only)
5. Commit changes with message: "Fix: ${linearIssue.title}"
6. Push to origin

IMPORTANT: Only modify files in src/, app/, components/, or pages/ directories.
  `.trim();

  // Invoke Cloudflare Container
  try {
    const containerUrl = `https://api.cloudflare.com/client/v4/accounts/${env.CLOUDFLARE_ACCOUNT_ID}/workers/containers/${env.CONTAINER_BINDING_NAME || 'bugbot-executor'}/execute`;

    const response = await fetch(containerUrl, {
      method: 'POST',
      headers: {
        'Authorization': `Bearer ${env.CLOUDFLARE_API_TOKEN}`,
        'Content-Type': 'application/json'
      },
      body: JSON.stringify({
        prompt,
        env: {
          GITHUB_TOKEN: env.GITHUB_TOKEN,
          LINEAR_API_KEY: env.LINEAR_API_KEY
        }
      })
    });

    if (!response.ok) {
      throw new Error(`Container execution failed: ${response.statusText}`);
    }

    const result = await response.json() as {
      success: boolean;
      changes?: string;
      error?: string;
    };

    return result;
  } catch (error) {
    return {
      success: false,
      error: error instanceof Error ? error.message : 'Unknown error'
    };
  }
}
